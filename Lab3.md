# *Лабораторная работа №3*
## *Файл postgresql.conf и представление pg_file_settings*

Имя конфигурационного файла содержится в доступном для чтения параметре config_file. Имя конфигурационного файла можно указать с помощью ключа командной строки при запуске postgres.
```
postgres=# SHOW config_file;
config_file               
-----------------------------------------
 /etc/postgresql/16/main/postgresql.conf
(1 row)
```
Посмотрим небольшой фрагмент конфигурационного файла. 
```
=# SELECT pg_read_file('/etc/postgresql/16/main/postgresql.conf', 1516, 861) \g (tuples_only=on format=unaligned)
#------------------------------------------------------------------------------
# FILE LOCATIONS
#------------------------------------------------------------------------------

# The default values of these variables are driven from the -D command-line
# option or PGDATA environment variable, represented here as ConfigDir.

data_directory = '/var/lib/postgresql/16/main'		# use data in another directory
					# (change requires restart)
hba_file = '/etc/postgresql/16/main/pg_hba.conf'	# host-based authentication file
					# (change requires restart)
ident_file = '/etc/postgresql/16/main/pg_ident.conf'	# ident configuration file
					# (change requires restart)

# If external_pid_file is not explicitly set, no extra PID file is written.
external_pid_file = '/var/run/postgresql/16-main.pid'			# write an extra PID file
					# (change requires restart)
```
Обычно эти директивы располагаются в завершающей части файла postgresql.conf:
postgres=# sudo grep -A3 ^include /etc/postgresql/16/main/postgresql.conf

Чтобы увидеть настройки в конфигурационных файлах, можно обратиться к представлению pg_file_settings:

postgres-# SELECT sourceline, name, setting, applied, error FROM pg_file_settings;
ERROR:  syntax error at or near "sudo"
LINE 1: sudo grep -A3 ^include /etc/postgresql/16/main/postgresql.co...

## *Представление pg_settings*
 Возьмем для примера параметр work_mem. Он определяет объем памяти, выделяемый для таких операций, как сортировка или хеш-соединение. Не для всех запросов значения по умолчанию может быть достаточно. Подробнее о параметре work_mem можно узнать в курсе QPT «Оптимизация запросов».

Действующие значения всех параметров доступны в представлении pg_settings. Вот что в нем содержится для параметра work_mem: 
```
postgres=# SELECT name, setting, unit, boot_val, reset_val,
  source, sourcefile, sourceline, pending_restart, context
FROM pg_settings
WHERE name = 'work_mem' \gx
-[ RECORD 1 ]---+---------
name            | work_mem
setting         | 4096
unit            | kB
boot_val        | 4096
reset_val       | 4096
source          | default
sourcefile      | 
sourceline      | 
pending_restart | f
context         | user
```
## *Порядок применения строк*

При перечитывании конфигурации сначала читается основной файл, а затем дополнительные. Если один и тот же параметр встречается несколько раз, то устанавливается значение из последней считанной строки.

Например, укажем дважды параметр work_mem в дополнительном файле конфигурации: 
```
postgres=# echo work_mem=12MB | sudo tee /etc/postgresql/16/main/conf.d/work_mem.conf

work_mem=12MB

postgres=# echo work_mem=8MB | sudo tee -a /etc/postgresql/16/main/conf.d/work_mem.conf

work_mem=8MB
```
Содержимое файла /etc/postgresql/16/main/conf.d/work_mem.conf: 
```
postgres-# SELECT sourcefile, sourceline, name, setting, applied
FROM pg_file_settings WHERE sourcefile LIKE '%/work_mem.conf';
ERROR:  syntax error at or near "echo"
LINE 1: echo work_mem=8MB | sudo tee -a /etc/postgresql/16/main/conf...
```
 Для параметра work_mem поле context имеет значение user. Значит, параметр можно менять прямо во время сеанса, и позже мы увидим, как это сделать.

А чтобы изменить значение во всех сеансах, достаточно перечитать файлы конфигурации: 
```
postgres=# SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 row)
```
Убедимся, что параметр work_mem получил значение из второй строки: 
```
postgres=# ^[[200~SELECT name, setting, unit, boot_val, reset_val,
postgres-#   source, sourcefile, sourceline, pending_restart, context
postgres-# FROM pg_settings
postgres-# WHERE name = 'work_mem'\gx~
invalid command \gx~
Try \? for help.
```
## *Команда ALTER SYSTEM и файл postgresql.auto.conf* 
Для примера установим параметр work_mem: 
```
postgres-# ALTER SYSTEM SET work_mem TO '16mb';
ERROR:  syntax error at or near "
INE 1: SELECT name, setting, unit, boot_val, reset_val,
```
В результате выполнения команды значение 16MB записано в файл postgresql.auto.conf: 
```
postgres=# SELECT pg_read_file('postgresql.auto.conf')
\g (tuples_only=on format=unaligned)
Do not edit this file manually!
It will be overwritten by the ALTER SYSTEM command.
```
Но это значение не применено: 
```
postgres=# SHOW work_mem;
 work_mem 
----------
 4MB
(1 row)
```
 Чтобы применить изменение work_mem, перечитаем файлы конфигурации: 
```
 postgres=# SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 row)

postgres=#  SELECT name, setting, unit, boot_val, reset_val,
  source, sourcefile, sourceline, pending_restart, context
FROM pg_settings
WHERE name = 'work_mem'\gx
-[ RECORD 1 ]---+---------
name            | work_mem
setting         | 4096
unit            | kB
boot_val        | 4096
reset_val       | 4096
source          | default
sourcefile      | 
sourceline      | 
pending_restart | f
context         | user
```
Для удаления строк из postgresql.auto.conf используется команда ALTER SYSTEM RESET: 
```
postgres=# ALTER SYSTEM RESET work_mem;
ALTER SYSTEM
postgres=# SELECT pg_read_file('postgresql.auto.conf')
\g (tuples_only=on format=unaligned)
# Do not edit this file manually!
# It will be overwritten by the ALTER SYSTEM command.
```
Еще раз перечитаем конфигурацию. Теперь восстановится значение из work_mem.conf: 
```
postgres=# SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 row)

postgres=# SELECT name, setting, unit, boot_val, reset_val,
  source, sourcefile, sourceline, pending_restart, context
FROM pg_settings
WHERE name = 'work_mem'\gx
-[ RECORD 1 ]---+---------
name            | work_mem
setting         | 4096
unit            | kB
boot_val        | 4096
reset_val       | 4096
source          | default
sourcefile      | 
sourceline      | 
pending_restart | f
context         | user
```
## *Установка параметров для текущего сеанса*
```
postgres=# SET work_mem TO '24MB';
SET
```
## *Чтение значений параметров во время выполнения*
```
postgres=# SHOW work_mem;
 work_mem 
----------
 24MB
(1 row)
```
Сбросим значение к тому, которое действовало в начале сеанса: 
```
postgres=# RESET work_mem;
RESET
```
## *Установка параметров внутри транзакции*

Откроем транзакцию и установим новое значение work_mem: 
```
postgres=# BEGIN;
BEGIN
postgres=*# SET work_mem TO '64MB';
SET
postgres=*# SHOW work_mem;
 work_mem 
----------
 64MB
(1 row)


postgres=*# COMMIT;
COMMIT

```
По завершении транзакции значение восстанавливается:
``` 
postgres=# SHOW work_mem;
 work_mem 
----------
 64MB
(1 row)
```
Параметры можно создавать прямо во время сеанса, в том числе с предварительной проверкой на существование.

В имени пользовательских параметров обязательно должна быть точка, чтобы отличать их от стандартных параметров. 
```
postgres=# SELECT CASE
  WHEN current_setting('myapp.currency_code', true) IS NULL
    THEN set_config('myapp.currency_code', 'RUB', false)
  ELSE
    current_setting('myapp.currency_code')
END;
 current_setting 
-----------------
 RUB
(1 row)
```
Теперь myapp.currency_code можно использовать как глобальную переменную сеанса: 
```
postgres=# SELECT current_setting('myapp.currency_code');
 current_setting 
-----------------
 RUB
(1 row)
```