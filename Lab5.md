# *Лабораторная работа №5*
## *Видимость версий строк* 
Создадим таблицу:
```
postgres=# CREATE TABLE t(s text);
ERROR:  relation "t" already exists

postgres=# INSERT INTO t VALUES ('Первая версия');
ERROR:  invalid input syntax for type integer: "Первая версия"
LINE 1: INSERT INTO t VALUES ('Первая версия');

postgres=# BEGIN;
BEGIN
postgres=*# SELECT pg_current_xact_id();
 pg_current_xact_id 
--------------------
                751
(1 row)
```
 Транзакция видит первую (и пока единственную) версию строки: 
```
 postgres=*# SELECT *, xmin, xmax FROM t;
 id |  s  | xmin | xmax 
----+-----+------+------
  1 | foo |  745 |    0
  2 | bar |  746 |    0
  3 | baz |  747 |    0
  4 | xyz |  750 |    0
(4 rows)
```
 Здесь скрытые столбцы показывают номера транзакций, ограничивающих видимость версии строки: xmin — номер предыдущей транзакции, которая создала версию, а xmax=0 означает, что эта версия актуальна.

Теперь начнем другую транзакцию в другом сеансе:
``` 
postgres=*# BEGIN;
WARNING:  there is already a transaction in progress
BEGIN
postgres=*# SELECT pg_current_xact_id();
 pg_current_xact_id 
--------------------
                751
(1 row)
```
Транзакция видит ту же единственную версию: 
```
postgres=*# SELECT *, xmin, xmax FROM t;
 id |  s  | xmin | xmax 
----+-----+------+------
  1 | foo |  745 |    0
  2 | bar |  746 |    0
  3 | baz |  747 |    0
  4 | xyz |  750 |    0
(4 rows)
```
Теперь изменим строку во второй транзакции. 
```
postgres=*# UPDATE t SET s = 'Вторая версия';
UPDATE 4
```
Вот что получилось: 
```
postgres=*#  SELECT *, xmin, xmax FROM t;
 id |       s       | xmin | xmax 
----+---------------+------+------
  1 | Вторая версия |  751 |    0
  2 | Вторая версия |  751 |    0
  3 | Вторая версия |  751 |    0
  4 | Вторая версия |  751 |    0
(4 rows)
```
 Теперь зафиксируем изменения. 
```
postgres=*# COMMIT;
COMMIT
```
Что теперь увидит первая транзакция? 
```
postgres=# SELECT *, xmin, xmax FROM t;
 id |       s       | xmin | xmax 
----+---------------+------+------
  1 | Вторая версия |  751 |    0
  2 | Вторая версия |  751 |    0
  3 | Вторая версия |  751 |    0
  4 | Вторая версия |  751 |    0
(4 rows)
```
 Теперь и первая транзакция видит вторую версию строки.

После фиксации первая версия строки больше не будет видна ни в одной транзакции. 
```
postgres=# COMMIT;
WARNING:  there is no transaction in progress
COMMIT
```
## *Блокировки*

Повторим наш опыт, но теперь пусть обе транзакции попытаются изменить одну и ту же строку. 
```
postgres=# BEGIN;
BEGIN

postgres=*# UPDATE t SET s = 'Третья версия' RETURNING *;
 id |       s       
----+---------------
  1 | Третья версия
  2 | Третья версия
  3 | Третья версия
  4 | Третья версия
(4 rows)

UPDATE 4
```
И во второй транзакции: 
```
postgres=*# BEGIN;
WARNING:  there is already a transaction in progress
BEGIN
postgres=*# UPDATE t SET s = 'Четвертая версия' RETURNING *;
 id |        s         
----+------------------
  1 | Четвертая версия
  2 | Четвертая версия
  3 | Четвертая версия
  4 | Четвертая версия
(4 rows)

UPDATE 4
```
Вторая транзакция «повисла»: она не может изменить строку, пока первая транзакция не снимет блокировку. 
```
postgres=*# COMMIT;
COMMIT
```
Теперь вторая транзакция может продолжить выполнение: 

Обе транзакции зафиксировали свои изменения. Первый сеанс снова читает таблицу и видит актуальную строку — это результат, зафиксированный второй транзакцией: 
```
postgres=# SELECT * FROM t;
 id |        s         
----+------------------
  1 | Четвертая версия
  2 | Четвертая версия
  3 | Четвертая версия
  4 | Четвертая версия
(4 rows)
```